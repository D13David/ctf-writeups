# BCACTF 5.0

## Encryptor Shop

> After realizing how insecure the systems of many companies are (they're always getting hacked), I decided to start offering Encryption as a Service (EaaS). With such a strong guarantee of security, I'll even give you the source code AND my encrypted super secret flag.
> 
> Author: Mudasir
> 
> [`server.py`](server.py)

Tags: _crypto_

## Solution
For this challenge we get a python script. The server is hosted an we can connect via netcat.

```bash
Welcome to the enc-shop!
What can I encrypt for you today?
Enter text to encrypt: abc
Here is your encrypted message: 10712532403856654804205667210022902268111679478403394087163132946223440815519798566519289400883526437657112583473227052747689303156219812931965929393123862535498765545031428140268469778499393208608025338037337969195663342885442067212148255630412400070296572357870921446486754389637610791380891309479123534244920782006584182918587902429754536358463632888454473694937325320712263349444259631070794014611682793843553435699476089459038899921369611749077137231643007370516184119066762986303846480863479911875919423366018025856847748644536732573657180897963759476494097190971122837813409038995314115174346784690430500827998
c = 10712532403856654804205667210022902268111679478403394087163132946223440815519798566519289400883526437657112583473227052747689303156219812931965929393123862535498765545031428140268469778499393208608025338037337969195663342885442067212148255630412400070296572357870921446486754389637610791380891309479123534244920782006584182918587902429754536358463632888454473694937325320712263349444259631070794014611682793843553435699476089459038899921369611749077137231643007370516184119066762986303846480863479911875919423366018025856847748644536732573657180897963759476494097190971122837813409038995314115174346784690430500827998
Here is the public key for your reference:
n = 18171500049573300410131724655273437708147043950293950769343660990590793218037136132056291253596751233840426655569496655055167873399542811800771798662997612184053824146424071110907544446819642779576111481017529105732287799557508221857035389842449298331229556298378862127536258777211591173748379835460733110686910212921056306374979921478306410217514356767887867378543801887057290684252785928001376909958060152871119159545742355633072441490653495827685095437655966010525809490082488072448655338061173320472686471780246555207655702205127796973657714732028420419167968505823265155387042262244867153185368821590172459862599
e = 65537
```

Ok, we can encrypt messages and get alongside the encrypted message `c` also the public key `n` and `e`. We can encrypt three messages in total, afterwards the program gives us the encrypted flag.

```bash
Thank you for encrypting with us!
In order to guarantee the security of your data, we will now let you view the encrypted flag.
Would you like to view it? (yes or no) yes
Here is the encrypted flag: 9147792501207610526595618455977520037429135421745441490247232030544549439984115279205470499809974733111229934938284398108613998725883070550989863720836026631411067002479186217577840120252867275941939157098004510435896293674496216860381759330400862498059472882239766297056926688551207567141877958753226336994678200739870715279483460622730547747331588493069189369897796129249781351195399020099387194602184570806622577186860670622436089011316474284646858623894995317948030400517113443715215884120798488138983770795045932809790753259538590397199725478562087302453554599899173534815575577640952029534148503172101043663972
Here is the public key for your reference:
n = 14126338733475416815838404983397240117303232031635693651857335527717143136465984373853972601589264783526454360304309933037399393273327789993698160129240505066708294957158044769925889469572264120545697151207756579573720183308455407965314359792595051688442499113282007285549615952135352207848718233659474442496392089003163652373421861384597642883416914400581765259995587129288124328239737169931132700517475868065309779355949389001403894192851394805982848944968047874183547068764860293583201116525285168984024215551022148436657912807694013181065581401794879875585161380567587252041326087903663834061041804187848072995433
```

Lets check out the code. We have a loop that reads user input and encrypt the input. The encryption is vanilla `RSA`, three primes are generated (`p`, `q`, `r`) and the modulo `n` uses `p` and `q`. Also the private key is calculated but never used in code...

```python
p = getPrime(1024)
q = getPrime(1024)
r = getPrime(1024)
n = p * q
phi = (p - 1) * (q - 1)
e = 65537
d = pow(e, -1, phi)

...

for _ in range(3):
    message = input("Enter text to encrypt: ")
    m = bytes_to_long(message.encode())
    c = pow(m, e, n)
    print(f"Here is your encrypted message: {c}")
    print(f"c = {c}")
    print("Here is the public key for your reference:")
    print(f"n = {n}")
    print(f"e = {e}")
```

Interestingly the flag uses another modulo that is the product of `p` and `r`. Since `p` is used for both modulos this is a problem really, since we can retrieve `p` by finding the `greatest common divisor` of both modulos (read about this [`here`](https://www.johndcook.com/blog/2018/12/19/rsa-with-one-known-prime/)). And since we have `p` we can also retrieve `r` and with both primes known we also have the private key for decryption.

```python
m = bytes_to_long(flag.encode())
n = p*r
c = pow(m, e, n)
print(f"Here is the encrypted flag: {c}")
print("Here is the public key for your reference:")
print(f"n = {n}")
```

Lets put this to work. We just copy both moduli (here now called n1, for n being `p*q` and n2 for n being `p*r`) to our code as well as the encrypted flag. Then we can retrieve `p` by finding the `gcd` of both moduli. 

```python
from math import gcd
from Crypto.Util.number import long_to_bytes

n1 = 12373559896539607142121115024656730940694542716905321786861738265208808146796673018685938500489374832474340155589955274640215216657780160213119803453342397132515630858816259990439560410901095522119946139628229512831068082312203046669467287563295128512675431270490952855065211621111128158600203343357497129035496885823380980978052695600759043568694187335157740916625709084198182459928246138986177442122917825729135210517839962784508113582511614008613080969573828260958063238679846802840977584899747853025072153024062146393105484377960417276242951512316387995094522613775069845972155527672552829624043496698679056331451

n2 = 14126338733475416815838404983397240117303232031635693651857335527717143136465984373853972601589264783526454360304309933037399393273327789993698160129240505066708294957158044769925889469572264120545697151207756579573720183308455407965314359792595051688442499113282007285549615952135352207848718233659474442496392089003163652373421861384597642883416914400581765259995587129288124328239737169931132700517475868065309779355949389001403894192851394805982848944968047874183547068764860293583201116525285168984024215551022148436657912807694013181065581401794879875585161380567587252041326087903663834061041804187848072995433

flag_encrypted = 9147792501207610526595618455977520037429135421745441490247232030544549439984115279205470499809974733111229934938284398108613998725883070550989863720836026631411067002479186217577840120252867275941939157098004510435896293674496216860381759330400862498059472882239766297056926688551207567141877958753226336994678200739870715279483460622730547747331588493069189369897796129249781351195399020099387194602184570806622577186860670622436089011316474284646858623894995317948030400517113443715215884120798488138983770795045932809790753259538590397199725478562087302453554599899173534815575577640952029534148503172101043663972

p = gcd(n1, n2)
```

Next we can divide `n2` by `p` to remove this factor and get `r` as the result.

```python
r = n2 // p
```

With both primes we finally can create the private key and decrypt the flag.

```python
e = 65537
phi = (p-1)*(r-1)
d = pow(e, -1, phi)

flag_decrypted = long_to_bytes(pow(flag_encrypted, d, n2))
print(flag_decrypted.decode())
```

Flag `bcactf{w0w_@lg3br@_d3in48uth934r}`