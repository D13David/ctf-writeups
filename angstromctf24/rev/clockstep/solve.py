
def parseLine(line):
    addr, value, op = line.split()
    return (int(addr[2:],16), int(value[2:],16), op)

check_table = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0xa8, 0x00, 0x64, 0x00, 0x00, 0xcd, 0x00, 0x00, 0x00, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00,
    0xf1, 0x00, 0x00, 0x00, 0x63, 0x00, 0x11, 0x20, 0xa2, 0x29, 0xd7, 0x00, 0x00, 0x49, 0x00, 0xf1,
    0x00, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x87, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xa8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x00, 0x07, 0x6e, 0x00, 0x00, 0xa7, 0x00, 0x00, 0x00, 0x00, 0xc2, 0x3c, 0x00, 0x00,
    0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc4, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x9c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x22, 0x00, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x41,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0x64,
    0x00, 0x48, 0x00, 0x00, 0x00, 0xeb, 0x00, 0x00, 0x00, 0x1f, 0x00, 0xed, 0x00, 0x00, 0x00, 0x00]

trace = open("clockstep.txt", "r").readlines()
secure_bits = []
shuffle_pairs = []
secure_buffer = []
secure_buffer2 = []
index = 0
addr = 0

# part 1
# scan the bus trace and reconstruct the content of the secure storage. the storage content is split
# in two parts, first 48 bytes contain 'check values' which are tested against values in 'check_table'
# the second 48 bytes contain the index into the check_table xor the flag characters
while index < len(trace):
    prev_addr = addr
    addr, value, op = parseLine(trace[index])

    # BEQ shufSkip, if branch is taken the bit in secure buffer was 1, leak first part of secure buffer
    if addr == 0x801e:
        addr, value, op = parseLine(trace[index+2])
        secure_bits.append('1' if addr == 0x8020 else '0')

    # read from input array and record all shuffle operations to reverse shuffling, 
    # later. 806d is last address of 'shuffleInput'
    if 0x200 <= addr < 0x230 and op == 'W' and prev_addr < 0x806d:
        ofs = addr - 0x200
        shuffle_pairs.append(ofs)
    
    # read from shuf_table, this leaks the second part of the secure buffer
    if 0x8191 <= addr < 0x8291: 
        _, value, _ = parseLine(trace[index-6])
        secure_buffer2.append((addr - 0x8191) ^ value)

    index = index + 1

for i in range(0, len(secure_bits), 8):
    secure_buffer.append(int("".join(secure_bits[i:i+8]),2))

# part 2
# retrieve flag by combining the secure storage content. second part encodes the flag characters
# therefore we need to xor with the correct index of 'check_table'. the value to check for can
# be found in first part of secure storage. small pitfall, there are some duplicate entries in
# 'check_table' therefore search for characters in valid range, the remaining three duplicates
# are just hardcoded (?)
flag = [0]*48
duplicates = [1,0,0]
for i in range(48):
    chars = []
    for j in range(len(check_table)):
        if check_table[j] == secure_buffer[i]:
            char = j^secure_buffer2[i]
            if 32 <= char <= 127:
                chars.append(char)
    if len(chars) > 1:
        flag[i] = chars[duplicates.pop()]
    else:
        flag[i] = chars[0]

# part 3
# redo shuffle operation and print flag
shuffle_pairs = shuffle_pairs[::-1]
for i in range(0, len(shuffle_pairs), 2):
    index1 = shuffle_pairs[i+0]
    index2 = shuffle_pairs[i+1]
    flag[index1], flag[index2] = flag[index2], flag[index1]

print("".join([chr(x) for x in flag]))
